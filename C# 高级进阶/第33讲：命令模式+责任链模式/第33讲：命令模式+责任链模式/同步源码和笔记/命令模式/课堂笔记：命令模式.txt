
【设计模式之-命令模式】CommandPattern

引出：通过去饭店吃饭，排号--》集中选菜--》传递给后台厨师--》服务员上菜。

如果对于就餐环节，没有规范的话会出现很多问题。原因：“行为的请求者”和“行为的实现者”紧密耦合！

消费者--》服务员--》厨师  服务员就是解耦的！

1.概念思想：将行为的请求者和行为的实现者分离。命令在批量执行的时候，也可以根据需要撤销。

2.核心业务：将一个请求（方法），封装为一个独立的对象。

3. 命令模式的实现（解耦、解耦，再解耦！）

【1】CommandReceiver：命令的接收者，也就是最终要执行的命令（其实就是我们要封装的具体任务）

任何一个能够完成具体任务的对象，都是可以视为命令的接受者。

【2】ICommand 将CommandReceiver里面的方法进行抽象，抽象成一个DoWork（）方法。

【3】ConcreteCommand 将CommandReceiver里面的每一个方法，封装为具体的对象。

Method1（）=》Method1Command....  体现的是：合久必分

【4】CommandInvoker  命令的激发者（发布者），我们可以理解成饭店的服务员。给Client端进行命令的批量调用，并可以实现撤销操作。  体现的是：分久必合

【5】Client端的实现。

4.命令模式的好处总结

【1】轻松设计命令队列，实现批量执行。

【2】命令是否执行，可以主动控制。

【3】可以轻松撤销命令。

【4】命令扩展的时候，只需要增加命令，不影响其他现有命令。符合OOP“开-闭原则”。


















